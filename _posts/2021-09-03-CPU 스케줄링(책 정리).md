# CPU 스케줄링(책 정리)

### 스케줄링의 개요

- **식당 관리자의 스케줄링**

  - 식당 관리자의 역할
    - 예약 관리
    - 좌석 관리
    - 주문 관리
    - 조리 순서 관리
    - 손님 요청 관리
  - CPU 스케줄러
    - 운영체제에서 이러한 식당 관리자의 역할을 담당하는 것
    - 스케줄링은 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일

- **스케줄링의 단계**

  - 고수준 스케줄링

    - 장기 스케줄링, 작업 스케줄링, 승인 스케줄링이라고 함
    - 시스템 내의 전체 작업 수를 조절하는 것을 말함
    - 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정
    - 시스템 내에서 동시에 실행 가능한 프로세스의 총 개수가 정해짐

  - 저수준 스케줄링

    - 어떤 프로세스에 CPU를 할당할지 결정
    - 어떤 프로세스를 대기 상태로 보낼지 결정

  - 중간 수준 스케줄링

    - 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부화를 막아
    - 프로세스의 상태 중 보류 상태에 해당
    - 저수준 스케줄링이 원만하게 이루어지도록 완충하는 역할을 함

  - 스케줄링의 단계 정리

    ![img](https://postfiles.pstatic.net/MjAxOTAxMDNfNjYg/MDAxNTQ2NDgxNjkyNTgz.P41v5UDxFSKK-txdbP1In1yg8Jol8w1xVPQ7ltu4xhsg.GzRSxh0V8H2Ztja0tqRFCzBqsO-wiETC-oEpTR0z6oMg.PNG.dltnqls442/SE-f7330c76-695b-4b4b-813a-188ecdaf62c9.png?type=w966)

- **스케줄링의 목적**

  - CPU 스케줄링의 목적
    - 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안됨
    - 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 함
    - 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호해야 함
    - 확성성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야 함. 또한 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되게 해야 함
    - 반응 시간 보장 : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 함
    - 무한 연기 방지 : 특정 프로세스의 작업이 무한으로 연기되어서는 안됨

### 스케줄링 시 고려 사항

- **선점형 스케줄링과 비선섬형 스케줄링**

  - 선점형 스케줄링

    - 운영체제가 필요하다고 판단하면 실행 상태에 있는 작업을 중단시키고 새로운 작업을 시작할 수 있음
    - 하나의 프로세스가 CPU를 독점할 수 없기 때문에 빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합
    - 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용

  - 비선점형 스케줄링

    - 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 계속 실행됨
    - 선점형 스케줄링보다 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적음
    - CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세스가 오랫동안 기다리게 되어 전체 시스템의 처리율이 떨어짐
    - 과거의 일괄 작업 시스템에서 사용하던 방식

  - 선점형 스케줄링과 비선점형 스케줄링의 비교

    | 구분      | 선점형                                                       | 비선점형                                                     |
    | :-------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
    | 작업 방식 | 실행 상태에 있는 작업을 중단시키고 새로운 작업을 실행할 수 있다. | 실행 상태에 있는 작업이 완료될 때까지 다른 작업이 불가능하다. |
    | 장점      | 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합하다. | CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다.    |
    | 단점      | 문맥 교환의 오버헤드가 많다.                                 | 기다리는 프로세스가 많아 처리율이 떨어진다.                  |
    | 사용      | 시분할 방식 스케줄러에 사용된다.                             | 일괄 작업 방식 스케줄러에 사용된다.                          |
    | 중요도    | 높다.                                                        | 낮다.                                                        |

- **프로세스 우선순위**

  - 프로세스 우선순위
    - 커널 프로세스의 우선순위가 일반 프로세스보다 높음
    - 시스템에는 다양한 우선순위의 프로세스가 공존하며, 우선순위가 높은 프로세스가 CPU를 먼저, 더 오래 차지함
    - 시스템에 따라 높은 숫자가 높은 우선순위를 나타내기도 하고, 낮은 숫자가 높은 우선순위를 나타내기도 함

- **CPU 집중 프로세스와 입출력 집중 프로세스**

  - CPU 집중 프로세스
    - 수학.연산과 같이 CPU를 많이 사용하는 프로세스
    - CPU 버스트가 많은 프로세스
  - 입출력 집중 프로세스
    - 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스
    - 입출력 버스트가 많은 프로세스
  - 우선 배정
    - 스케줄링을 할 때 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템의 효율이 향상됨

- **전면 프로세스와 후면 프로세스**

  - 전면 프로세스
    - GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스
    - 현재 입력과 출력을 사용하는 프로세스
    - 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 함
  - 후면 프로세스
    - 사용자와 상호작용이 없는 프로세스
    - 압축 프로그램처럼 사용자의 입력 없이 작동하기 때문에 일괄 작업 프로세스라고도 함
    - 전면 프로세스의 우선순위가 후면 프로세스보다 높음

- **정리**

  ![img](https://postfiles.pstatic.net/MjAxOTAxMDNfNDYg/MDAxNTQ2NDgyNzIzNTEz._CjOxh_1_HUICoHTUNtRze48Mf40tYAg8iMg6GnyYwcg._rzEVtmNHwhl8mrH7HejD1-OHUuQHGTiETAQdUIhjl8g.PNG.dltnqls442/SE-73c12e7f-96b5-4dfb-96d0-b3a1c4eeeb93.png?type=w966)

### 다중 큐

- **준비 상태의 다중 큐**
  - 준비 상태의 다중 큐
    - 프로세스는 준비 상태에 들어올 때마다 자신의 우선순위에 해당하는 큐의 마지막에 삽입됨
    - CPU 스케줄러는 우선순위가 가장 높은 큐의 맨 앞에 있는 프로세스에 CPU를 할당함
  - 프로세스의 우선순위를 배정하는 방식
    - 고정 우선순위 방식 : 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식 , 프로세스가 작업하는 동안 우선순위가 변하지 않기 때문에 구현하기 쉽지만, 시스템의 상황이 시시각각 변하는데 우선순위를 고정하면 시스템의 변화에 대응하기 어려워 작업 효율이 떨어짐
    - 변동 우선순위 방식 : 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식, 구현하기 어렵지만 시스템의 효율성을 높일 수 있음
- **대기 상태의 다중 큐**
  - 대기 상태의 다중 큐
    - 시스템의 효율을 높이기 위해 대기 상태에서는 같은 입출력을 요구한 프로세스끼리 모아놓음
  - 준비 큐
    - 한 번에 하나의 프로세스를 꺼내어 CPU를 할당
  - 대기 큐
    - 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태를 옮김

### 스케줄링 알고리즘

- **스케줄링 알고리즘의 종류**

  | 구분              | 종류                                                         |
  | :---------------- | :----------------------------------------------------------- |
  | 비선점형 알고리즘 | FCFS 스케줄링, SJF 스케줄링, HRN 스케줄링                    |
  | 선점형 알고리즘   | 라운드 로빈 스케줄링, SRT 스케줄링, 다단계 스케줄링, 다단계 피드백 큐 스케줄링 |
  | 둘 다 가능        | 우선순위 스케줄링                                            |

- **스케줄링 알고리즘의 선택 기준**

  - 스케줄링 알고리즘의 평가 기준

    - CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법, 가장 이상적인 수치는 100%이지만 실제로는 여러 가지 이유로 90%에도 못미침

    - 처리량 : 단위 시간당 작업을 마친 프로세스의 수, 수치가 클수록 좋은 알고리즘

    - 대기 시간 : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간, 시간이 짧을수록 좋음

    - 응답 시간 : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간, 시간이 짧을수록 좋음

    - 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는데까지 걸리는 시간, 대기 시간과 실행 시간을 더한 값

      ![img](https://postfiles.pstatic.net/MjAxOTAxMDNfMTEg/MDAxNTQ2NTE4NjAwMDU3.2aPKAofXI1wuxCEVIzm0LX6zP8zjrHoIfVAWc5u7P70g.peAdcEKNQKflHXDrNmf2jolAaDrZTyc-2a-Gg-yviU0g.PNG.dltnqls442/SE-ba4a17bc-92e0-4247-bc44-35c6e3028f4f.png?type=w966)

  - 평균 대기 시간

    - 모든 프로세스의 대기 시간을 합한 뒤 프로세스의 수로 나눈 값

- **FCFS 스케줄링**

  - FCFS 스케줄링의 동작 방식
    - 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식
    - 한 번 실행되면 그 프로세스가 끝나야만 다음 프로세스를 실행할 수 있음
    - 큐가 하나라 모든 프로세스는 우선 순위가 동일함

| NOTE_FCFS는 FIFO(First In First Out)라고도 하는데, 일반적으로는 FIFO는 큐를 가리키는 말이기 때문에 이와 구분 하기 위해 스케줄링 알고리즘에서는 FCFS라고 부른다. 참고로 FIFO와 대응되는 FILO(First In Last Out)는 스택을 가리킨다. |
| ------------------------------------------------------------ |

- FCFS 스케줄링의 성능
  - 프로세스 도착 순서와 작업 시간의 예(단위 : 밀리초)

| 도착 순서 | 도착 시간 | 작업 시간 |
| :-------- | :-------- | :-------- |
| P1        | 0         | 30        |
| P2        | 3         | 18        |
| P3        | 6         | 9         |

![img](https://postfiles.pstatic.net/MjAxOTAxMDNfMzcg/MDAxNTQ2NTIxMDgxNTc4.7xg4gVeU7Gk0qRsJoXQ_1j8p-f2nMvdnN4cIb-w58Wkg.G3wx_LsiM1S7m8v2QAgx7OGsNdCqS5ZAaCbX0yiztWIg.PNG.dltnqls442/SE-d908ab14-42bd-4775-87a0-ed24c2319737.png?type=w966)

- 평균 대기 시간은 (0+27+42)/3=23밀리초

  - FCFS 스케줄링의 평가
    - 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어지는 문제가 있는데 이를 콘보이 효과 또는 호위 효과라고 함
    - 현재 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어짐

- **SJF 스케줄링**

  - SJF 스케줄링의 동작 방식

    - 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
    - 최단 작업 우선 스케줄링이라고도 함
    - FCFS 스케줄링의 콘보이 효과를 완화하여 시스템의 효율성을 높이는 것

  - SJF 스케줄링의 성능

    ![img](https://postfiles.pstatic.net/MjAxOTAxMDNfNzcg/MDAxNTQ2NTIxNDc2MTU5.AfRTyJnEFc6WmMPCIpYq9djqD_kuSBY4BpwYDdXQcPAg.kIbScJh2AaohoqWhE5HmgiUVBfM_1E3D1l-Mjf4oFnUg.PNG.dltnqls442/SE-2cb4eb9d-1e9b-4312-ad88-d1b814e8d1f0.png?type=w966)

- 평균 대기 시간은 (0+24+36)/3=20밀리초

  - SJF 스케줄링의 평가
    - 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어려움
    - 공평하지 못함
  - 에이징(나이 먹기)
    - 프로세스가 양보할 수 있는 상한선을 정하는 방식
    - 프로세스가 자신의 순서를 양보할 때마다 나이를 한 살씩 먹어 최대 몇 살까지 양보하도록 규정하는 것

- **HRN 스캐줄링**

  - HRN 스케줄링의 동작 방식
    - SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘
    - 최고 응답률 우선 스케줄링이라고도 함
    - 서비스를 받기 위해 기다린 시간과 CPU 사용 기간을 고려하여 스케줄링을 하는 방식
    - 프로세스의 우선순위를 결정하는 기준은 다음과 같음

![img](https://postfiles.pstatic.net/MjAxOTAxMDNfOCAg/MDAxNTQ2NTIyMzI5MjE4.-seDcYFOF9Q21G4PTGTZYFHjO4c1fchJpWBqDTbiEeog.KK7f9GLQPevdttNOhK-qNQ0RMQm4pkN_Kx7Q783QPREg.PNG.dltnqls442/SE-162a02e7-c3b8-42d2-98ef-00112f3f97db.png?type=w966)

- HRN 스케줄링의 평가
  - 실행 시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기 시간을 고려하여 아사 현상을 완화
  - 대기 시간이 긴 프로세스의 우선순위를 높임으로써 CPU를 할당받을 확률을 높임
  - 여전히 공평성이 위배되어 많이 사용되지 않음
- **라운드 로빈 스케줄링**
  - 라운드 로빈 스케줄링의 동작 방식
    - 한 프로세스가 할당받은 시간(타임 슬라이스)동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
    - 선점형 알고리즘 중 가장 단순하고 대표적인 방식
    - 프로세스들이 작업을 완료할 때까지 계속 순환하면서 실행됨
  - 라운드 로빈 스케줄링의 성능

![img](https://postfiles.pstatic.net/MjAxOTAxMDNfMjg3/MDAxNTQ2NTIzMTU0ODE5.WKBLmps1RmvNuBu9-SxGF-VKf_HMOSS2r83GKjqqIDAg.uy3qG5KH34uf5X4FphU66QI8f9t5ohmZbPcLn1vO3igg.PNG.dltnqls442/SE-76f8677d-b1e2-482c-bc59-92abfae25a14.png?type=w966)

- 총 대기 시간은 0(P1)+7(P2)+14(P3)+19(P1)+19(P2)+8(P1)=67밀리초
- 평균 대기 시간은 67/3=22.33밀리초



+ 타임 슬라이스의 크기와 문맥 교환

  + 라운드 로빈 스케줄링이 효과적으로 작동하려면 문맥 교환에 따른 추가 시간을 고려하여 타임 슬라이스를 적절히 설정해야 함

+ 타임 슬라이스가 큰 경우

  + 타임 슬라이스가 너무 크면 하나의 작업이 끝난 뒤 다음 작업이 시작되는 것처럼 보임

+ 타임 슬라이스가 작은 경우

  + 타임 슬라이스를 너무 작게 설정하면 시스템의 전반적인 성능이 떨어짐
  + 타임슬라이스는 되도록 작게 설정하되 문맥 교환에 걸리는 시간을 고려하여 적당한 크기로 하는 것이 중요
  + 유닉스 운영체제에서는 타임 슬라이스가 대략 100밀리초임

+ **SRT 우선 스케줄링**

  + SRT 우선 스케줄링의 동작 방식

    + 기본적으로 라운드 로빈 스케줄링을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 프로세스를 선택

  + SRT 스케줄링의 성능

    ![img](https://postfiles.pstatic.net/MjAxOTAxMDNfNzgg/MDAxNTQ2NTI0NDA1NTAz.-IijaKdIrZqmOlRz5ipqw7KgDxcV5ifr6Ey0sdMYZA8g.sUTa-UEt7a-sZUu75QBKsgpojSFj1BhLSFTp3kRZcO8g.PNG.dltnqls442/SE-bd4ce54d-e63c-475e-8c52-98ea4f0c437a.png?type=w966)

+ 총 대기 시간은 0(P1)+4(P3)+16(P2)+27(P1)=47밀리초

+ 평균 대기 시간은 47/3=15.66밀리초

  + SRT 스케줄링의 평가
    + 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산
    + 남은 시간이 더 적은 프로세스와 문맥 교환을 해야 하므로 SJF 스케줄링에는 없는 작업이 추가
    + 운영체제가 프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않음

+ **우선순위 스케줄링**

  + 우선순위 스케줄링의 동작 방식
    + 프로세스는 중요도에 따라 우선순위를 갖는데 이러한 우선순위를 반영한 스케줄링 알고리즘

| 도착 순서 | 도착 시간 | 작업 시간 | 우선순위 |
| --------- | :-------- | :-------- | :------- |
| P1        | 0         | 30        | 3        |
| P2        | 3         | 18        | 2        |
| P3        | 6         | 9         | 1        |

![img](https://postfiles.pstatic.net/MjAxOTAxMDNfMTUg/MDAxNTQ2NTI0ODczNjk3.GuIdk__xrFXqKhfZSIVXJiY3e43dHnRBk_WdGNskVdcg.Cuae9H-VpPtQWpIL4W6YpHAw1Yx9STi9p5kRmOAmDeYg.PNG.dltnqls442/SE-50a35962-7323-4f16-8dfe-41a8679ecd2d.png?type=w966)

FCFS 스케줄링에 우선순위를 적용한 결과



- 우선순위 적용
  - (비선점형 방식)SJF 스케줄링 : 작업 시간이 짧은 프로세스에 높은 우선순위를 부여
  - (비선점형 방식)HRN 스케줄링 : 작업 시간이 짧거나 대기 시간이 긴 프로세스에 높은 우선순위를 부여
  - (선점형 방식)SRT 스케줄링 : 남은 시간이 짧은 프로세스에 높은 우선순위를 부여
- 고정 우선순위 알고리즘
  - 한 번 우선순위를 부여받으면 종료될 때까지 우선순위가 고정됨
  - 단순하게 구현할 수 있지만 시시각각 변하는 시스템의 상황을 반영하지 못해 효율성이 떨어짐
- 변동 우선순위 알고리즘
  - 일정 시간마다 우선순위가 변함
  - 일정 시간마다 우선순위를 새로 계산하고 이를 반영하기 때문에 시스템이 복잡하지만 시스템의 상황을 반영하여 효율적인 운영 가능
- 우선순위 스케줄릉의 평가
  - 준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로 공평성을 위배하고 아사 현상을 일으킴
  - 준비 큐에 있는 프로세스의 순서를 무시하고 프로세스의 우선순위를 매번 바꿔야 하기 때문에 오버헤드가 발생하여 시스템의 효율성을 떨어뜨림



- **다단계 큐 스케줄링**
  - 우선순위에 따라 준비 큐를 여러 개 사용하는 방식
  - 프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위를 큐에 삽입됨
  - 우선순위는 고정형 우선순위를 사용
  - 상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작됨
- **다단계 피드백 큐 스케줄링**
  - 프로세스가 CPU를 한 번씩 할당받아 실행될 때마다 프로세스의 우선순위를 낮춤으로써, 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제 완화
  - 프로세스의 우선순위가 낮아진다고 할지라도 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않음
  - 우선순위에 따라 타임 슬라이스의 크기가 다름
  - 다단계 피드백 큐 스케줄링에서 마지막 큐에 있는(우선순위가 가장 낮은) 프로세스는 무한대의 타임 슬라이스를 얻음
  - 무한대의 타임 슬라이스를 얻는다는 것은 프로세스가 실행 상태에 들어가면 CPU를 빼앗기지 않고 끝까지 작업을 마친다는 의미
  - 오늘날의 운영체제가 CPU 스케줄링을 위해 일반적으로 사용하는 방식으로, 변동 우선순위 알고리즘의 전형적인 예임