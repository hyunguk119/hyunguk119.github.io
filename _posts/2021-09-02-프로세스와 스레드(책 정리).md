# 프로세스와 스레드(책 정리)

### 프로세스의 개요

- **프로세스의 개념**

  - 프로그램 : 저장장치에 저장되어 있는 정적인 상태 (사용자 입장)
  - 프로세스 : 실행을 위해 메모리에 올라온 동적인 상태 (컴퓨터 입장)

- **요리사 모형에의 비유**

  - 일괄 작업 방식의 요리

    - 레스토랑에 테이블이 하나만 있는 것

    - 요리사는 주문서를 받은 순서대로 요리를 함

    - 손님의 식사가 끝나야 다음 손님을 받을 수 있어 작업 효율이 떨어짐

    - 주방에서는 주문 순서가 도착한 순서대로 요리를 하기 위해 '주문 목록'을 사용하는데 주문 목록은 큐로 처리됨

      | NOTE_ 큐는 먼저 들어온 테이터가 먼저 빠져나가는 자료 구조이다. 반대로 스택은 먼저 들어온 데이터가 마지막에 빠져나간다. 큐는 양쪽이 뚫려 있는 파이프, 스택은 한쪽만 뚫려 있는 파이프라고 생각하면 된다. |
      | ------------------------------------------------------------ |

- **시분할 방식의 요리**

  - 요리사는 1명이지만 시간을 적당히 배분하여 여러 가지 요리를 동시에 하는 방식

- **프로그램에서 프로세스로의 전환**

  - **프로세스 제어 볼록**
    - 운영체제는 프로그램을 메모리의 적당한 위치로 가져옴과 동시에 주문서에 해당하는 작업 지시서를 만드는데, 이 작업 지시서가 프로세스 제어 볼록이다.
    - 프로세스 구분자 : 각 프로세스 구분
    - 메모리 관련 정보 : 프로세스의 메모리 위치 정보
    - 각종 중간값 : 프로세스가 사용했던 중간값 저장
    - 프로그램이 프로세스가 된다는 것은 운영체제로부터 프로세스 제어 볼록을 얻는다는 뜻
    - 프로세스가 종료된다는 것은 해당 프로세스 제어 볼록이 폐기된다는 뜻

- **프로세스와 프로그램의 관계**

  - 프로세스 = 프로그램 + 프로세스 제어 블록
  - 프로그램 = 프로세스 + 프로세스 제어 블록

- **프로세스의 상태**

  - **프로세스의 네 가지 상태**![img](https://postfiles.pstatic.net/MjAxOTAxMDJfMTk2/MDAxNTQ2Mzk2MTM2Njkz.gVELwCQ_uxny8kQNUr3c0LQS8XjLGfTfj-5W8j2H4H8g.roX68Zq3ANPCW0NUlCi9PaH3Qf4Hd2_g66YalF4-eTYg.PNG.dltnqls442/SE-3417cdaf-5ff9-4cf5-af9a-76e6787647fb.png?type=w966)

  - 생성 상태 : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태

  - 준비 상태 : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태

  - 실행 상태 : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태

  - 완료 상태 : 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입, 프로세스 제어 볼록이 사라진 상태

  - 디스패치 : 준비 상태의 프로세스 중 하나를 골라 실행 상태로 바꾸는 CPU 스케줄러의 작업

  - 타임아웃 : 프로세스는 자신에게 주어진 하나의 타임 슬라이스 동안 작업을 끝내지 못하면 다시 준비 상태로 돌아감

  - **프로세스의 다섯 가지 상태**

    ![img](https://postfiles.pstatic.net/MjAxOTAxMDJfODUg/MDAxNTQ2Mzk2NjYwNTUz.AVVhUCtefKHS2I__LVJemEsceEyFhv0u4bLlaevql7wg.x6Ljo27Cf4jarbt5YPDwOF16cV7Z8Fr1qCQ3blxp6k4g.PNG.dltnqls442/SE-aeb9de7d-506a-4a7a-aa71-c2b258e46178.png?type=w966)

| 상태      | 설명                                                         | 작업                                                         |
| :-------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 생성 상태 | 프로그램을 메모리에 가져와 실행 준비가 완료된 상태이다.      | 메모리 할당, 프로세스 제어 블록 생성                         |
| 준비 상태 | 실행을 기다리는 모든 프로세스가 자기 차례를 기다리는 상태이다. 실행될 프로세스를 CPU 스케줄러가 선택한다. | dispatch(PID): 준비 -) 실행                                  |
| 실행 상태 | 선택된 프로세스가 타임 슬라이스를 얻어 CPU를 사용하는 상태이다. 프로세스 사이의 문맥 교환이 일어난다. | timeout(PID):실행 -) 준비 , exit(PID): 실행 -) 완료 , block(PID): 실행 -) 대기 |
| 대기 상태 | 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태이다. 입출력이 완료되면 준비 상태로 간다. | wakeup(PID): 대기 -) 준비                                    |
| 완료 상태 | 프로세스가 종료된 상태이다. 사용하던 모든 데이터가 정리된다. 정상 종료인 exit와 비정상 종료인 abort를 포함한다. | 메모리 삭제, 프로세스 제어 블록 삭제                         |

- **휴식 상태와 보류 상태**
  - 휴식 상태 : 프로세스가 작업을 일시적으로 쉬고 있는 상태
  - 보류 상태 : 프로세스가 메모리에서 잠시 쫓겨난 상태로 휴식 상태와 차이가 있음
  - 프로세스는 다음과 같은 경우에 보류 상태가 된다.
    - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
    - 프로그램에 오류가 있어서 실행을 미루어야 할 때
    - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
    - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
    - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때

### 프로세스 제어 블록과 문맥 교환

- **프로세스 제어 블록**

  - 프로세스 제어 블록(PID)

    - 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조
    - 모든 프로세스는 고유의 프로세스 제어 블록을 가짐
    - 프로세스 생성 시 만들어져서 프로세스가 실행을 완료하면 폐기됨

  - 프로세스 제어 블록의 구성

    ![img](/home/hyunguk/snap/typora/42/.config/Typora/typora-user-images/image-20210902031253627.png)

  - **포인터**

    - 같은 입출력을 기다리는 프로세스끼리 모여 있는 상태

  - **프로세스 상태**

    - 프로세스 상태에는 생성, 준비, 실행, 대기, 보류 준비, 보류 대기 등이 있다. 이는 프로세스가 현재 어떤 상태에 있는지를 나타낸다.

  - **프로세스 구분자**

    - 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자를 저장

  - **프로그램 카운터**

    - 다음에 실행될 명렁어의 위치를 가리키는 프로그램 카운터의 값을 저장

  - **프로세스 우선순위**

    - 프로세스의 중요도는 각각 다르다. 사용자 프로세스보다 중요도가 큰 커널 프로세스는 우선순위가 높고, 사용자 프로세스끼리도 우선순위가 다르다. 이처럼 우선순위로 인해 실행 순서가 달라진다.

  - **각종 레지스터 정보**

    - 실행할 때 사용한 레지스터의 값을 보관해야 다음에 실행할 수 있기 때문에 자신이 사용하던 레지스터의 중간값을 보관

  - **메모리 관리 정보**

    - 프로세스 제어 블록에는 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 메모리 보호를 위해 사용하는 경계 레지스터 값과 한계 레지스터 값 등이 저장

  - **할당된 자원 정보**

    - 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보를 말함

  - **계정 정보**

    - 계정 정보,CPU 할당 시간, CPU 사용 시간 등으로, 이러한 정보는 프로세스 제어 블록에 저장

  - **부모 프로세스 구분자와 자식 프로세스 구분자**

    - 프로세스 제어 블록에는 부모 프로세스를 가리키는 PPID와 자식 프로세스를 가리키는 CPID 정보도 저장된다.

- **문맥 교환**

  - 문맥 교환의 의미

    - CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업
    - 실행 상태에서 나가는 프로세스 제어 블록에는 지금까지의 작업 내용을 저장하고, 반대로 실행 상태로 들어오는 프로세스 제어 블록의 내용으로 CPU가 다시 세팅됨

  - 문맥 교환의 절차

    ![img](https://postfiles.pstatic.net/MjAxOTAxMDJfMTA3/MDAxNTQ2NDAzNTk3NTM5.F5iXwuu9SBbBcD9swcafueDiWT_DIrx-xnVHHRtiOggg.4f-41GY-Snjz_f9-msW8TvMtOn2R8oqTukEUsj7NBfgg.PNG.dltnqls442/SE-a2e28234-0b00-4a01-9a7b-e1ec10cfcb3d.png?type=w966)

### 프로세스의 연산

- 프로세스의 구조

  ![img](https://postfiles.pstatic.net/MjAxOTAxMDJfMTIg/MDAxNTQ2NDA0MDgxODQ4.dXLTtFua9ATJgE0_3ukQeHZJ3w2g8neS6nqOsmnQp3wg.b_Jd1VsVfVugwEPe__VV1wBhv2vagIYTnF5P93BAasIg.PNG.dltnqls442/SE-50726b68-af95-47c0-b241-421db748b4ee.png?type=w966)

  

  - **코드 영역**
    - 프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 한다. (코드 영역에 탑재되며 탑재된 코드는 읽기 전용으로 처리 된다.)
  - **데이터 영역**
    - 코드가 실행 되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳이다. (물론 상수로 선언된 변수는 읽기 전용이지만 대부분의 변수는 읽기와 쓰기가 가능하다.)
  - **스택 영역**
    - 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳이다. (운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역이므로 사용자에게는 보이지 않는다.)

- **프로세스의 생성과 복사**

  - fork() 시스템 호출의 개념

    - 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
    - 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어짐

    | fork() 시스템 호출은 실행 중인 프로세스를 복사하는 함수이다. 이때 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스로서 부모-자식 관계가 된다. |
    | ------------------------------------------------------------ |

  - fork() 시스템 호출의 동작 과정

    - fork() 시스템 호출을 하면 프로세스 제어 블록을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어짐
    - 단, 프로세스 제어 블록의 내용 중 일부가 변경되는데 변경되는 부분은 다음과 같음
      - 프로세스 구분자
      - 메모리 관련 정보
      - 부모 프로세스 구분자와 자식 프로세스 구분자

  - fork() 시스템 호출의 장점

    - 프로세스 생성 속도가 빠름
    - 추가 작업 없이 자원을 상속할 수 있음
    - 시스템 관리를 효율적으로 할 수 있음

- **프로세스의 전환**

  - exec() 시스템 호출의 개념
    - 기존의 프로세스를 새로운 프로세스로 전환하는 함수
    - exex() 시스템 호출은 이미 만들어진 프로세스의 구조를 재활용하는 것

  | -fork() : 새로운 프로세스를 복사하는 시스템 호출             |
  | ------------------------------------------------------------ |
  | **-exec() : 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출** |

- **프로세스의 계층 구조**

  - 유닉스의 프로세스 계층 구조
    - 운영체제에 있는 모든 프로세스는 init 프로세스의 자식이 되어 트리 구조를 이룸![img](https://postfiles.pstatic.net/MjAxOTAxMDJfMjMw/MDAxNTQ2NDA1MTE3MDgw.jKbCTf2Ak8VsOL9QTuS7ZcIRN4NOTlTIvsSC979UtuUg.YQdmP3plp-vltbAdiGArYZWPoiBY_D2gkzV-bnC6C4Eg.PNG.dltnqls442/SE-1cf267df-279f-45f0-8c6f-9d118bc7abf8.png?type=w966)
  - 프로세스 계층 구조의 장점
    - 여러 작업의 동시 처리
    - 프로세스의 재사용이 용이
    - 용이한 자원 회수
      - 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템을 관리하기가 수월
  - 미아 프로세스
    - 프로세스가 종료된 후에도 비정상적으로 남아 있는 프로세스
    - C언어의 exit() 또는 return() 문은 자식 프로세스가 작업이 끝났음을 부모 프로세스에 알리는 것으로 미아 프로세스 발생을 미연에 방지함

### 스레드

- **스레드의 정의**

  - CPU 스케줄러가 CPU에 전달하는 일 하나

  - CPU가 처리하는 작업의 단위는 프로세스로부터 전달받은 스레드

  - 운영체제 입장에서의 작업 단위는 프로세스이고, CPU 입장에서의 작업 단위는 스레드

    | 스레드 : 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위이다. |
    | ------------------------------------------------------------ |

- **프로세스와 스레드의 차이**

  - 프로세스끼리는 약하게 연결되어 있는 반면 스레드끼리는 강하게 연결되어 있음

- **스레드 관련 용어**

  - 멀티스레드 : 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄히는 프로세스 운영 기법
  - 멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법
  - 멀티프로세싱 : CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경
  - CPU 멀티스레드 : 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법

- **멀티스레드의 구조와 예**

  - 멀티태스킹의 낭비요소
    - fork() 시스템 호출로 프로세스를 복사하면 코드 영역과 데이터 영역의 일부가 메모리에 중복되어 존재하며, 부모-자식 관계이지만 서로 독립적인 프로세스이므로 이러한 낭비 요소를 제가할 수 없음
  - 멀티태스킹과 멀티스레드의 차이
    - fork() 시스템 호출로 여러 개의 프로세스를 만들면 필요 없는 정적 영역이 여러 개가 됨
    - 멀티스레드는 코드, 파일 등의 자원을 공유함으로써 자원의 낭비를 막고 효율성을 향상함
  - 멀티스레드의 장단점
    - 멀티스레드의 장점
      - 응답성 향상
      - 자원 공유
      - 효율성 향상
      - 다중 CPU 지원
    - 멀티스레드의 단점
      - 모든 스레드가 자원을 공유하기 때문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미침
      - 인터넷 익스플로러에서 여러 개의 화면을 동시에 띄웠는데 그 중 하나에 문제가 생기면 인터넷 익스플로러 전체가 종료됨

- **멀티스레드 모델**

  - 커널 스레드와 사용자 스레드
    - 커널 스레드 : 커널이 직접 생성하고 관리하는 스레드
    - 사용자 스레드 : 라이브러리에 의해 구현된 일반적인 스레드
  - 사용자 레벨 스레드
    - 사용자 프로세스 내에 여러 개의 스레드가 존재하지만 커널의 스레드 하나와 연결되기 때문에 1 to N 모델이라고 부름
    - 라이브러리가 직접 스케줄링을 하고 작업에 필요한 정보를 처리하기 때문에 문맥 교환이 필요없음
    - 커널 스레드가 입출력 작업을 위해 대기 상태에 들어가면 모든 사용자 스레드가 같이 대기
  - 커널 레벨 스레드
    - 커널이 멀티스레드를 지원하는 방식
    - 하나의 사용자 스레드가 하나의 커널 스레드와 연결되기 때문에 1 to 1 모델이라고 부름
    - 커널 레벨에서 모든 작업을 지원하기 때문에 멀티 CPU를 사용할 수 있고, 하나의 스레드가 대기 상태에 있어도 다른 스레드는 작업을 계속할 수 있음
    - 커널의 기능을 사용하므로 보안에 강하고 안정적으로 작동
    - 문맥 교환을 할 때 오버헤드 때문에 느리게 작동
  - 멀티레벨 스레드
    - 사용자 레벨 스레드와 커널 레벨 스레드를 혼합한 방식이므로 M to N 모델이라고 부름
    - 커널 스레드가 대기 상태에 들어가면 다른 커널 스레드가 대신 작업을 하여 사용자 레벨 스레드보다 유연하게 작업을 처리할 수 있음
    - 커널 레벨 스레드를 같이 사용하기 때문에 여전히 문맥 교환 시 오버헤드가 있어 사용자 레벨 스레드만큼 빠르지 않음
    - 빠르게 움직여야 하는 스레드는 사용자 레벨 스레드로 작동하고, 안정적으로 움직여야 하는 스레드는 커널 레벨 스레드로 작동함

