# 가상 메모리의 기초(책 정리)

### 가상 메모리의 개요

- **가상 메모리 시스템**
  - 가상 메모리 개념
    - 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술
    - 프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경 쓰지 않고 메모리를 마음대로 사용할 수 있음
  - 가상 메모리의 크기와 주소
    - 가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있는지 상관없이 0번지부터 시작하는 연속된 메모리 공간을 가짐

| 가상 메모리의 크기 = 가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리(실제 메모리)와 스왑 영역을 합한 크기이다. |
| ------------------------------------------------------------ |

- **가상 메모리의 메모리 분할 방식**

| 구분             | 가상 메모리                   | 물리 메모리          |
| :--------------- | :---------------------------- | :------------------- |
| 최대 메모리 크기 | CPU의 비트 값에 의존          | CPU의 비트 값에 의존 |
|                  | 세크먼테이션                  | 가변 분할 방식       |
| 메모리 분할 방식 | 페이징                        | 고정 분할 방식       |
|                  | 세그먼테이션-페이징 혼용 기법 |                      |
| 주소 지정 방식   | 가상 주소                     | 절대 주소, 상대 주소 |

- **매핑 테이블의 필요성과 역할**
  - 매핑 테이블의 필요성과 역할
    - 가상 메모리 시스템에서 가상 주소는 실제로 물리 주소나 스왑 영역 중 한 곳에 위치하며, 메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리함
    - 페이징 기법에서 사용하는 매핑 테이블은 페이지 매핑 테이블 또는 페이지 매핑이라고 부름
    - 세그먼테이션 기법에서 사용하는 매핑 테이블은 세그먼테이션 매핑 테이블 또는 세그먼테이션 테이블이라고 부름

### 페이징 기법

- **페이징 기법의 구현**

  - 페이징 기법	

    - 고정 분할 방식을 이용한 가상 메모리 관리 기법으로, 물리 주소 공간을 같은 크기로 나누어 사용함
    - 물리 메모리의 각 영역은 가상 주소의 페이지와 구분하기 위해 프레임이라고 부름
    - 프레임도 페이지와 마찬가지로 번호를 매겨 관리함. 페이지와 프레임의 크기는 같음

  - 페이징 기법의 주소 변환

    - 주소 변환 과정

      - 가상 주소를 물리 주소로 변환하는 과정
        - 1. 가상 주소 30번지가 어느 페이지에 있는지 찾는다. 30번지는 페이지 3의 0번째 위치에 있다.
          2. 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아낸다.
          3. 최종적으로 물리 메모리 프레임 1의 0번째 위치에 접근한다. 이 주소가 가상 주소 30번지의 물리 주소이다.
      - 프로세스가 가상 주소 18번지에 어떤 값을 저장하려고 할 때의 주소 변환 과정
        - 1. 가상 주소 18번지가 어느 페이지에 있는지 찾는다. 18번지의 페이지 1의 8번째 위치에 있다.
          2. 페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임 3에 있다는 것을 알아낸다.
          3. 프로세스가 저장하려는 값을 프레임 3의 8번 위치에 저장한다.

    - 정형화된 주소 변환

      - 페이징 기법에서는 가상 주소를 VA=<P,D>로 표현 (VA는 가상 주소, P는 페이지, D는 페이지의 처음 위치에서 해당 주소까지의 거리)

      - 페이징 기법에서의 주소 변환은 가상 주소 VA=<P,D>를 물리주소 PA=<F,D>로 변환하는 것

        (PA는 물리 메모리의 주소를 가리키는 용어, F는 프레임, D는 프레임의 처음 위치에서 해당 주소까지의 거리)

| 페이징 기법의 주소 변환 과정 = VA=<P,D> - ) PA=<F,D> |
| ---------------------------------------------------- |

- 페이지 테이블은 페이지 번호, 프레임 번호로 구성된 페이지 테이블 엔트리의 집합



- 16bit CPU의 주소 변환 예

  | 가상 주소를 <P,D>로 변환하는 공식 = P = 나눗셈(가상 주소/한 페이지의 크기)의 몫 , D = 나눗셈(가상 주소/한 페이지의 크기)의 나머지 |
  | ------------------------------------------------------------ |



- **페이지 테이블 관리**
  - 페이지 테이블 관리
    - 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 모아놓음
    - 시스템 내에는 여러 개의 프로세스가 존재하고 프로세스마다 하나의 페이지 테이블이 있기 때문에 전체 페이지 테이블의 크기는 프로세스의 수에 비례해서 커짐
    - 한 번에 실행하는 프로세스의 수가 많으면 페이지 테이블의 크기가 같이 커지고, 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어듦
    - 각 프로세스가 메모리에 접근하려고 할 때 메모리 관리자는 페이지의 테이블의 위치를 재빨리 파악할 필요가 있음 따라서 각 페이지 테이블의 시작 주소를 페이지 테이블 기준 레지스터에 보관
    - 페이지 테이블 기준 레지스터는 각 프로세스의 프로세스 제어 블록에 저장되는 데이터로, 물리 메모리 내에 테이블의 시작 주소를 가지고 있음
  - 페이지 테이블 매핑 방식
    - 직접 매핑
      - 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식
      - 별다른 부가 작업 없이 바로 주소 변환이 가능하기 때문에 직접 매핑이라고 부름
    - 연관 매핑
      - 페이지 테이블 전체를 스왑 영역에서 관리하는 방식
      - 물리 메모리의 여유 공간이 작을 때 사용하는 방식으로, 모든 페이지 테이블을 저장장치의 스왑 영역에 저장하고 그 중 일부만 물리 메모리에 가지고 있음
    - 집합-연관 매핑
      - 연관 매핑의 문제를 개선한 방식
      - 모든 페이지 테이블을 스왑 영역에서 관리하고 일부만 물리 메모리로 가져온다는 것은 연관 매핑과 동일
      - 다만 연관 매핑에서는 물리 메모리에 있는 데이터가 무작위로 올라오기 때문에 원하는 프레임 번호를 얻기 위해 모든 테이블을 검색해야 하는 문제가 있음
      - 집합-연관 매핑에서는 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져옴
    - 역매핑
      - 앞의 세 가지 매핑과 반대로 페이지 테이블을 구성하는 방식
      - 직접 매핑, 연관 매핑, 집합-연관 매핑에서는 페이지 번호를 기준으로 테이블을 구성
      - 역매핑에서는 물리 메모리의 번호를 기준으로 테이블을 구성
      - 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시

### 세그먼테이션 기법

- **세그먼테이션 기법의 구현**
  - 세그먼테이션 테이블
    - 페이징 기법과 마찬가지로 세그먼테이션 기법도 매핑 테이블을 사용하는데 이를 세그먼테이션 테이블 또는 세그먼테이션 매핑 테이블이라고 함
    - 세그먼테이션 기법의 장점 : 메모리를 프로세스 단위로 관리하기 때문에 페이지 테이블이 작고 단순함
    - 세그먼테이션 기법의 단점 : 물리 메모리의 외부 단편화로 인해 물리 메모리 관리가 복잡함
- **세그먼테이션 기법의 주소 변환**
  - 가상 주소
    - 세그먼테이션 기법에서 가장 주소를 VA=<S,D>로 표현 (S는 세그먼트 번호, D는 세그먼트 시작 지점에서 해당 주소까지의 거리)
  - 프로세스 A의 32번지에 접근할 때 주소 변환 과정
    - 1. 먼저 가상 주소를 구한다. 프로세스 A는 세그먼트 0으로 분할되었으므로 S는 0이고 D는 32이다. 따라서 가상 주소는 VA=<0,32>이다.
      2. 세그먼테이션 테이블에서 세그먼트 0의 시작 주소를 알아낸 후 시작 주소 120에 거리 32를 더하여 물리 주소 152번지를 구한다. 이때 메모리 관리자는 거리가 세그먼트의 크기보다 큰지 점검한다. 만약 크다면(메모리를 벗어나면) 메모리 오류를 출력하고 해당 프로세스를 강제 종료하며, 크지 않다면 물리 주소를 구한다.
      3. 물리 주소 152번지에 접근하여 원하는 데이터를 읽거나 쓴다.

### 세그먼테이션-페이징 혼용 기법

- **메모리 접근 권한**

  | 구분   | 읽기 | 쓰기 | 실행 | 비교                 |
  | :----- | :--- | :--- | :--- | :------------------- |
  | 모드 0 | X    | X    | X    | 접근 불가            |
  | 모드 1 | X    | X    | O    | 실행만 가능          |
  | 모드 2 | X    | O    | X    | 실제로 사용하지 않음 |
  | 모드 3 | X    | O    | O    | 실제로 사용하지 않음 |
  | 모드 4 | O    | X    | X    | 읽기 전용            |
  | 모드 5 | O    | X    | O    | 읽고 실행 가능       |
  | 모드 6 | O    | O    | X    | 읽고 쓰기 가능       |
  | 모드 7 | O    | O    | O    | 제한 없음            |

  - 프로세스는 몸체에 해당하는 코드 영역, 프로세스가 사용하는 데이터를 저장하는 데이터 영역, 프로세스를 실행하는 데 필요한 스택 영역과 프로세스 제어 블록(PCB)으로 구성됨
  - 코드 영역 : 자기 자신을 수정하는 프로그램은 없기 때문에 읽기 및 실행 권한을 가짐
  - 데이터 영역 : 데이터는 크게 읽거나 쓸 수 있는 데이터와 읽기만 가능한 데이터로 나눌 수 있음 일반적인 변수는 읽거나 쓸 수 있으므로 읽기 및 쓰기 권한을 가지고 상수로 선언한 변수는 읽기 권한만 가짐



- **세그먼테이션-페이징 혼용 기법의 도입**

  - 페이지로 분할된 가상 주소 공간에서 서로 관련 있는 영역을 하나의 세그먼트로 묶어 세그먼테이션 테이블로 관리하고, 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리하는 방식
  - 각 세그먼 테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가짐
  - 페이징 기법에 세그먼테이션 테이블을 추가하고, 권한 비트와 같이 중복되는 데이터를 세그먼테이션 테이블로 옮겨 오면 테이블의 크기를 줄일 수 있음
  - 페이징 기법과 세그먼테이션 기법을 혼합하여 사용하면 순수 페이징 기법과 순수 세그먼테이션 기법의 장점만 취함으로써 메모리 관리를 효율적으로 할 수 있는데, 이를 세그먼테이션-페이징 혼용 기법이라고 함
  - 현재 운영체제는 이 방식을 사용하고 있음

- **세그먼테이션-페이징 혼용 기법의 주소 변환**

  - 세그먼테이션-페이징 혼용 기법에서 가상 주소를 물리 주소로 변환하는 과정

    - 1. 사용자가 어떤 주소에 있는 데이터를 요청하면 해당 주소가 몇 번째 세그먼트의 몇 번째 페이지로부터 얼마나 떨어져 있는지 계산하여 가상 주소 VA=<S,P,D>를 구한다.

      2. 세그먼테이션 테이블의 해당 세그먼트 번호로 가서 자신의 영역을 벗어나는 불법 접근이 아닌지, 권한이 없는 페이지에 접근하는 것은 아닌지 등을 확인한다. 만약 권한이 없는 페이지에 접근하거나 자신에게 주어진 메모리 영역을 벖어나면 세그먼테이션 오류(트랩)를 발생시켜 프로세스를 강제 종료하고, 그렇지 않으면 연결된 페이지 테이블로 간다.

      3. 페이지 테이블에서 해당 페이지가 어느 프레임에 저장되었는지 찾는다. 만약 물리 메모리에 프레임이 있다면 메모리에 바로 접근하고, 없다면 스왑 영역에 가서 해당 페이지를 물리 메모리로 가져온다.

      4. 물리 메모리에 있는 프레임의 처음 위치에서 D만큼 떨어진 곳에 접근하여 데이터를 읽거나 쓴다.

