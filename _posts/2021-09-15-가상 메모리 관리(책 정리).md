# 가상 메모리 관리(책 정리)

### 요구 페이징

- **요구 페이징의 개요**
  - 프로세스의 일부만 메모리로 가져오는 이유
    - 메모리를 효율적으로 관리하기 위해서 (메모리가 꽉 차면 관리하기 어려우므로 가급적 적은 양의 프로세스만 유지)
    - 응답 속도를 향상하기 위해서 (용량이 큰 프로세스를 전부 메모리로 가져와 실행하면 응답이 늦어질 수 있으므로 필요한 모듈만 올려 실행)
  - 포토샵 예
    - 포토샵의 본 프로그램만 올리고 필터는 사용자가 필요로 할 때마다 메모리로 가져오는 것이 효율적
- **페이지 테이블 엔트리의 구조**
  - 요구 페이징과 스왑 영역
    - 페이지가 스왑 영역에 있는 경우는 크게 두 가지
    - 요구 페이징으로 인해 처음부터 물리 메모리에 올라가지 못한 경우
    - 메모리가 꽉 차서 스왑 영역으로 옮겨 온 경우
  - 페이지 테이블 엔트리의 구성

![img](https://postfiles.pstatic.net/MjAxOTAxMTNfNzcg/MDAxNTQ3MzU5MTY5MTc4.JhoWA6uAhBN0yo6HTrF8KXpTMcYvaHG1KvrtIK8BI_Yg.gdthmfIisvXFG4ihyNT4-EAqFF8mowjdmCAC4R3oomMg.PNG.dltnqls442/페이지_테이블_엔트리의_구성.png?type=w966)

- 페이지 번호
- 프레임 번호
- 플래그 비트
  - 접근 비트 : 페이지가 메모리에 올라온 후 사용한 적인 있는지 알려주는 비트
  - 변경 비트 : 페이지가 메모리에 올라온 후 데이터의 변경이 있었는지 알려주는 비트
  - 유효 비트 : 페이지가 실제 메모리에 있는지를 나타내는 비트
  - 읽기, 쓰기, 실행 비트 : 페이지에 대한 읽기 권한, 쓰기 권한, 실행 권한을 나타내는 비트



- **페이지 부재**
  - 유효 비트
    - 가상 메모리의 페이지 테이블에는 페이지가 물리 메모리에 있는지, 스왑 영역에 있는지 표시하기 위해 유효 비트를 사용
    - 유효 비트가 0일 때 : 페이지가 메모리에 있으므로 주소 필드에 물리 메모리의 프레임 번호가 저장
    - 유효 비트가 1일 때 : 페이지가 스왑 영역에 있으므로 주소 필드에 스왑 영역 내 페이지의 주소가 저장
  - 페이지 부재
    - 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황
    - 페이지 부재가 발생하면 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야 함
  - 페이지 부재 처리 과정
    - 1. 프로세스가 페이지 3을 요청하면 페이지 테이블의 유효 비트가 1이기 때문에 페이지 부재가 발생함
      2. 메모리 관리자는 스왑 영역의 0번에 있는 페이지를 메모리의 비어 있는 프레임인 5로 가져옴(스왑인)
      3. 프레임 5로 접근하여 해당 데이터를 프로세스에 넘김
  - 페이지 교체
    - 페이지 부재가 발생하면 스왑 영역에 있는 페이지를 메모리의 빈 영역에 올리고 페이지 테이블을 갱신(업데이트)함
    - 어떤 페이지를 스왑 영역으로 내보낼지 결정하는 알고리즘을 페이지 교체 알고리즘이라고 함
    - 페이지 교체 알고리즘에 의해 스왑 영역으로 보낼 페이지를 대상 페이지라고 함
- **지역성**
  - 지역성
    - 페이지 교체 알고리즘이 쫓아낼 페이지를 찾을 때는 지역성을 바탕으로 함
    - 기억장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되는 성질
  - 지역성의 종류
    - 공간의 지역성 : 현재 위치에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 데이터에 접근할 확률이 보다 높다는 것
    - 시간의 지역성 : 현재를 기준으로 가장 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높다는 것
    - 순차적 지역성 : 여러 작업이 순서대로 진행되는 경향이 있다는 것

### 페이지 교체 알고리즘

- **페이지 교체 알고리즘의 개요**

  - 페이지 교체 알고리즘

    - 스왑 영역으로 보낼 페이지를 결정하는 알고리즘
    - 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 부재를 줄이고 시스템의 성능을 향상함

  - 페이지 교체 알고리즘의 종류

    | 종류               | 알고리즘  | 특징                                                         |
    | :----------------- | :-------- | :----------------------------------------------------------- |
    | 간단한 알고리즘    | 무작위    | 무작위로 대상 페이지를 선정하여 스왑 영역으로 보낸다.        |
    |                    | FIFO      | 처음 메모리에 올라온 페이지를 스왑 영역으로 보낸다.          |
    | 이론적 알고리즘    | 최적      | 미래의 접근 패턴을 보고 대상 페이지를 선정하여 스왑 영역으로 보낸다. |
    | 최적 근접 알고리즘 | LRU       | 시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보낸다.        |
    |                    | LFU       | 사용 빈도가 적은 페이지를 스왑 영역으로 보낸다.              |
    |                    | NUR       | 최근에 사용한 적이 없는 페이지를 스왑 영역으로 보낸다.       |
    |                    | FIFO 변형 | FIFO 알고리즘을 변형하여 성능을 높인다.                      |

  - 페이지 교체 알고리즘의 성능 평가 기준

    - 어떤 알고리즘이 다른 알고리즘보다 성능이 좋은지 평가하는 데에는 다양한 비교 방법이 있음
    - 이 책에서는 같은 메모리 접근 패턴을 사용하여 페이지 부재 횟수와 페이지 성공 횟수를 비교할 예정

- **무작위 페이지 교체 알고리즘**

  - 무작위 페이지 교체 알고리즘
    - 스왑 영역으로 쫓아낼 대상 페이지를 특별한 로직 없이 무작위로 선정함
    - 대부분 프로세스의 메모리 접근 패턴을 보면 메모리의 인접한 영역에 저장되는 지역성을 가지는데, 무작위 알고리즘은 이러한 지역성을 전혀 고려 하지 않기 때문에 자주 사용하는 페이지가 대상페이지로 선정되기도 함

- **FIFO 페이지 교체 알고리즘**

  - FIFO 페이지 교체 알고리즘
    - 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 스왑 영역으로 쫓아냄
    - 메모리가 꽉 차면 맨 위의 페이지가 스왑 영역으로 가고 나머지 페이지들이 위쪽으로 이동하며, 새로운 페이지가 아래쪽의 남은 공간에 들어옴
    - 무조건 오래된 페이지를 대상 페이지로 선정하기 때문에 성능이 떨어짐
    - 이러한 문제점을 개선한 것이 2차 기회 페이지 교체 알고리즘

- **최적 페이지 교체 알고리즘**

  - 최적 페이지 교체 알고리즘
    - 앞으로 사용하지 않을 페이지를 스왑 영역으로 옮김
    - 메모리가 앞으로 사용할 페이지를 미리 살펴보고 페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정함
    - 이상적인 방법이지만 실제로 구현할 수 없음
    - LRU 페이지 교체 알고리즘 : 페이지에 접근한 시간을 기준으로 대상 페이지를 선정
    - LFU 페이지 교체 알고리즘 : 페이지가 사용된 횟수를 기준으로 대상 페이지를 선정

- **LRU 페이지 교체 알고리즘**

  - LRU 페이지 교체 알고리즘
    - 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 옮김
  - 페이지 접근 시간에 기반한 구현
    - 페이지에 접근한 지 가장 오래된 페이지를 교체
  - 카운터에 기반한 구현
    - LRU 페이지 교체 알고리즘은 페이지 접근 시간을 기록하여 구현할 수도 있지만 카운터를 사용하여 구현할 수도 있음
  - 참조 비트 시프트 방식
    - 각 페이지에 일정 크기의 참조 비트를 만들어 사용하는 것
    - 참조 비트의 초깃값은 0이며 페이지에 접근할 때마다 1로 바뀜
    - 참조 비트는 주기적으로 오른쪽으로 한 칸씩 이동함
    - 참조 비트를 갱신하다가 대상 페이지를 선정할 필요가 있으면 참조 비트 중 가장 작은 값을 대상 페이지로 선정

- **LFU 페이지 교체 알고리즘**

  - LFU 페이지 교체 알고리즘
    - 페이지가 몇번 사용되었는지를 기준으로 대상 페이지를 선정함
    - 현재 프레임에 있는 페이지마다 그 동안 사용된 횟수를 세어 횟수가 가장 적은 페이지를 스왑 영역으로 옮김

- **NUR 페이지 교체 알고리즘**

  - NUR 페이지 교체 알고리즘

    - LRU, LFU 페이지 교체 알고리즘과 성능이 거의 비슷하면서도 불필요한 공간 낭비 문제를 해결한 알고리즘

    - '최근 미사용 페이지 교체 알고리즘' 이라고도 불림

    - 페이지마다 참조 비트와 변경 비트를 가짐

    - 참조 비트 : 페이지에 접근하면 1이 된다.

    - 변경 비트 : 페이지가 변경되면 1이 된다.

    - 모든 페이지의 초기 상태는(0,0)임

      ![img](https://postfiles.pstatic.net/MjAxOTAxMTNfMjQg/MDAxNTQ3MzYyNDMwNjYw.9i2PdYzKrYxEnYQFiViOEbhcQJOk7o05kroVAKzwyHsg.KdzI1L4OossFuHlDHpw65z5Wah6JIUVtF-FegMPOakAg.PNG.dltnqls442/대상_페이지_선정_순서.png?type=w966)

    - 참조 비트가 0인 페이지를 먼저 찾고, 없으면 변경 비트가 0인 페이지를 찾음

    - 만약 같은 비트의 페이지가 여러 개라면 무작위로 대상 페이지를 선정함

- **FIFO 변형 알고리즘**

  - 2차 기회 페이지 교체 알고리즘
    - FIFO 페이지 교체 알고리즘과 마찬가지로 큐를 사용
    - 차이점은 특정 페이지에 접근하여 페이지 부재 없이 상공할 경우 해당 페이지를 큐의 맨 뒤로 이동하여 대상 페이지에서 제외한다는 것
    - 성공한 페이지를 큐의 맨 뒤로 옮김으로써 기회를 한 번 더줌
  - 시계 알고리즘
    - 2차 기회 페이지 교체 알고리즘은 큐를 사용하지만 시계 알고리즘은 원형 큐를 사용
    - 스왑 영역으로 옮길 대상 페이지를 가리키는 포인터를 사용하는데, 이 포인터가 큐의 맨 바닥으로 내려가면 다음번에는 다시 큐의 처음을 가리키게 됨
    - 2차 기회 페이지 교체 알고리즘에 비해 각 페이지에 참조 비트가 하나씩 추가됨
    - 참조 비트의 초깃값은 0이며, 메모리에 있는 페이지를 성공적으로 참조하면 0에서 1로 변경됨
    - 만약, 가리키는 페이지가 스왑 영역으로 쫓겨나면 대상 포인터를 밑으로 이동
    - 참조 비트가 1인 페이지는 건너뛰고, 메모리의 바닥에 도착하면 원형 큐처럼 다시 메모리의 상단으로 이동

### 스레싱과 프레임 할당

- **스레싱**
  - 스레싱의 개념
    - 하드디스크의 입출력이 너무 많아져서 잦은 페이지 부재로 작업이 멈춘 것 같은 상태
  - 물리 메모리의 크기와 스레싱
    - 스레싱 발생 시점 : CPU가 작업하는 시간보다 스왑 영역으로 페이지를 보내고 새로운 페이지를 메모리에 가져오는 작업이 빈번해져서 CPU가 작업할 수 없는 상태에 이르게 되는 시점
    - 물리 메모리의 크기를 늘리면 스레싱 발생 지점이 늦춰져서 프로세스를 원한하게 실행할 수 있음
  - 스레싱과 프레임 할당
    - 어떤 프로세스에는 너무 적은 프레임을 할당하여 페이지 부재가 빈번하게 일어남
    - 어떤 프로세스에는 너무 많은 프레임을 할당하여 페이지 부재를 줄이는 대신 메모리를 낭비
    - 프로세스에 프레임을 할당하는 방식은 크게 정적 할당과 동적 할당으로 구분됨
- **정적 할당**
  - 균등 할당
    - 프로세스의 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당
    - 크기가 큰 프로세스의 경우 필요한 만큼 프레임을 할당받지 못하기 때문에 페이지 부재가 빈번하게 발생하고, 크기가 작은 프로세스의 경우 메모리가 낭비
  - 비례 할당
    - 프로세스의 크기에 비례하여 프레임을 할당하는 방식
    - 프로세스의 크기를 고려하지 않는 고정 할당보다 좀 더 현실적인 방식
    - 비례 할당의 두 가지 문제
      - 프로세스가 실행 중에 필요로 하는 프레임을 유동적으로 반영하지 못함
      - 사용하지 않은 메모리를 처음부터 미리 확보하여 공간을 낭비
- **동적 할당**
  - 작업집합 모델
    - 최근 일정 시간 동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지
    - 작업집합 모델에서 물리 메모리에 유지할 페이지의 크기를 작업집합 크기라고 함
    - 작업집합에 포함되는 페이지의 범위를 작업집합 윈도우라고 함
    - 델타 동안 참조된 10개의 페이지 중 작업집합에는 WS(t1)={1, 7, 5, 2, 3}이 삽입되며, 이 페이지들은 다음번 윈도우에 도달할 때까지 물리 메모리에 보존됨
    - 작업집합 크기가 5라는 것은 페이지에 다섯 번 접근할 때마다 작업집합을 갱신한다는 의미
  - 페이지 부재 빈도
    - 페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산하는 방식
    - 페이지 부재 비율이 상한선을 초과하면 할당한 프레임이 적다는 것을 의미하므로 프레임을 추가하여 늘림
    - 반대로 페이지 부재 비율이 하한선 밑으로 내려가면 메모리가 낭비된다는 의미이므로 할당한 프레임을 회수
    - 페이지 부재 빈도 방식은 프로세스를 실행하면서 추가적으로 페이지를 할당하거나 회수하여 적정 페이지 할당량을 조절함