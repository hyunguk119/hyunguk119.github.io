# 입출력 시스템과 저장장치(책 정리)

### 입출력장치와 채널

- **입출력장치와 채널**
  - 저속 주변장치 : 메모리와 주변장치 사이에 오고 가는 데이터의 양이 적어 데이터 전송률이 낮은 장치
  - 고속 주변장치 : 메모리와 주변장치 사이에 대용량의 데이터가 오고 가므로 데이터 전송률이 높은 장치
- **채널**
  - 데이터가 지나다니는 하나의 통로
- **채널 공유와 채널 분리**
  - 채널을 모든 주변장치가 공유하면 전체적으로 데이터 전송 속도가 느려짐
  - 전송 속도가 비슷한 장치끼리 묶어서 장치별로 채널을 할당하면 전체 데이터 전송 속도를 향상할 수 있음

#### 입출력 버스의 구조

- **초기의 구조**
  - 모든 장치가 하나의 버스로 연결
  - CPU가 작업을 진행하다가 입출력 명령을 만나면 직접 입출력장치에서 데이터를 가져왔는데 이를 폴링 방식이라고 함
- **입출력 제어기를 사용한 구조**
  - 입출력 제어기는 2개의 채널, 즉 메인버스와 입출력 버스로 나뉨
  - 메인버스 : 고속으로 작동하는 CPU와 메모리가 사용
  - 입출력 버스 : 주변장치가 사용
  - 입출력 제어기를 사용하면 느리 입출력장치로 인해 CPU와 메모리의 작업이 느려지는 것을 막을 수 있어 전체 작업 효율이 향상됨
- **입출력 버스의 분리**
  - 그래픽카드 같은 고속 주변장치가 키보드, 마우스 같은 저속 주변장치와 입출력 버스를 공유하면 입출력 속도가 현저히 저하되므로, 이를 해결하기 위해 입출력 버스를 고속 입출력 버스와 저속 입출력 버스로 분리하여 운영하고 있음
  - 결론적으로 현대의 컴퓨터는 CPU와 메모리를 연결하는 메인버스, CPU와 그래픽카드를 연결하는 그래픽 버스, 고속 입출력 버스와 저속 입출력 버스를 사용

#### 직접 메모리 접근

- **직접 메모리 접근**
  - CPU의 도움 없이도 메모리에 접근할 수 있도록 입출력 제어기에 부여된 권한
  - 입출력 제어기에는 직접 메모리에 접근하기 위한 DMA 제어기가 마련되어 있음
  - 채널 선택기는 여러 채널에서 전송된 데이터 중 어떤 것을 메모리로 보낼지 결정
  - CPU의 작업 공간과 DMA의 작업 공간이 겹치는 것
  - DMA 제어기가 전송하는 데이터를 '입출력 메모리' 라는 별도의 메모리에 보관했음
  - CPU가 작업하는 공간과 DMA 제어기가 데이터를 옮기는 공간을 분리하여 메인메모리를 운영하는데, 이를 메모리 맵 입출력이라고 부름

#### 인터럽트

- **입출력과 인터럽트**
  - 인터럽트는 주변장치의 입출력 요구나 하드웨어의 이상 현상을 CPU에 알려주는 역할을 하는 신호
  - 각 장치에는 IRQ라는 고유의 인터럽트 번호가 부여되어 있음
  - 인터럽트가 발생하면 CPU는 IRQ를 보고 어떤 장치에서 인터럽트가 발생했는지 파악
- **인터럽트의 종류**

| 종류          | 특징                                | 비교                         |
| :------------ | :---------------------------------- | :--------------------------- |
| 외부 인터럽트 | 입출력 및 하드웨어 관련 인터럽트    | 주변장치 변화, 하드웨어 이상 |
| 내부 인터럽트 | 프로세스의 오류로 발생하는 인터럽트 | 예외 상황 인터럽트           |
| 시그널        | 사용자의 요청으로 발생하는 인터럽트 | 자발적 인터럽트              |

- **인터럽트 벡터와 인터럽트 핸들러**
  - 인터럽트 벡터 : 여러 인터럽트 중 어떤 인터럽트가 발생했는지 파악하기 위해 사용하는 자료 구조
  - 인터럽트 벡터의 값이 1이면 인터럽트가 발생했다는 의미
  - 인터럽트 핸들러 : 인터럽트의 처리 방법을 함수 형태로 만들어놓은 것
  - 운영체제는 인터럽트가 발생하면 인터럽트 핸들러를 호출하여 작업을 함
  - 사용자 인터럽트인 시그널의 경우 자신이 만든 인터럽트 핸들러를 등록할 수도 있음

#### 버퍼링

- **버퍼의 역할**
  - 속도가 다른 두 장치의 속도 차이를 완화하는 역할을 함
  - 이중 버퍼를 사용하면 한 버퍼는 데이터를 담는 용도로 쓰고 또 한 버퍼는 데이터를 가져가는 용도로 쓸 수 있어 유용
- **버퍼 운용 시 주의점
  - 버퍼가 다 차지 않으면 버퍼가 다 찰 때까지 입출력장치에 자료가 전송되지 않는데, 이 상태에서 저장장치를 제거하면 버퍼 안의 데이터가 저장되지 않는 문제가 발생
  - 하드웨어 안전 제거를 사용하면 버퍼가 다 차지 않아도 강제로 버퍼의 내용이 저장장치로 옮겨지는데 이를 플러시라고 함
  - 플러시가 일어나면 저장장치의 손상을 방지하기 위해 입출력장치의 전원이 차단됨

### 디스크 장치



#### 디스크 장치의 종류

- **하드디스크**
  - 원반을 사용한 저장장치
  - 맨 앞에 있는 데이터나 맨 뒤에 있는 데이터에 접근하는 속도가 거의 비슷하여 수많은 시스템에서 본격적으로 하드디스크를 도입했음
  - 플래터 : 표면에 자성체가 발려 있어 자기를 이용하여 0과 1의 데이터를 저장할 수 있음
    - 플래터의 표면이 N극을 띠면 0으로, S극을 띠면 1로 인식함
    - 보통 2장 이상으로 구성되며 항상 일정한 속도로 회전함
  - 섹터와 블록
    - 섹터 : 하드디스크의 가장 작은 저장 단위
    - 하나의 섹터에는 한 덩어리의 데이터가 저장
    - 블록 : 여러 개의 섹터로 구성되며, 윈도우 운영체제에서는 블록 대신 클러스터라고 표현
  - 트랙과 실린더
    - 트랙 : 플래터에서 회전축을 중심으로 데이터가 기록되는 동심원, 즉 동일한 동심원상에 있는 섹터의 집합
    - 개념적으로 여러 개의 플래터에 있는 같은 트랙의 집합을 실린더라고 부름
  - 헤드와 플래터
    - 하드디스크에서 데이터를 읽거나 쓸 때는 읽기/쓰기 헤드를 사용
    - 헤드의 수는 데이터가 저장되는 플래터의 표면 수와 같음
- **CD**
  - 휴대할 수 있는 소형 원반에 데이터를 저장
  - 하드디스크와 마찬가지로 CD도 트랙과 섹터로 구성
  - 수평으로 움직이는 헤드가 트랙 사이를 움직이면서 데이터를 읽음
  - CD는 표면에 미세한 홈이 파여 있어 헤드에서 발사된 레이저가 홈에 들어가 반사가 되지 않으면 0으로, 반사되어 돌아오면 1로 인식
- **하드디스크와 CD의 비교**
  - 각속도 일정 방식의 회전 : 하드디스크의 플래터는 항상 일정한 속도로 회전하여 바깥쪽 트랙의 속도가 안쪽 트랙의 속도보다 훨씬 빠르다. 그러므로 가장 바깥쪽에 있는 섹터가 가장 안쪽에 있는 섹터보다 더 크다. 일정한 시간 동안 이동한 각도가 같다는 의미에서 이러한 방식을 각속도 일정이라고 한다.
  - 선속도 일정 방식의 회전 : CD에서 사용하는 선속도 일정 방식의 경우 어느 트랙에서나 단위 시간당 디스크의 이동 거리가 같은데, 이를 구현하려면 헤드가 안쪽 트랙에 있을 때는 디스크의 회전 속도를 빠르게 하고, 헤드가 바깥쪽 트랙으로 이동했을 때는 디스크의 회전 속도를 느리게 해야 한다.

#### 디스크 장치의 데이터 전송 시간

- **하드디스크에서 데이터를 전송하는 과정**
  - 1. 하드디스크의 특정 섹터에 저장된 데이터를 읽거나 쓰려면 그 섹터가 있는 트랙까지 헤드가 이동해야 함. 이처험 헤드가 현재 위치에서 그 트랙까지 이동하는 데 걸리는 시간을 탐색 시간이라고 함
    2. 특정 트랙까지 이동한 헤드는 플래터가 회전하여 원하는 섹터를 만날 때까지 기다림. 이처럼 원하는 섹터를 만날 때까지 회전하는 데 걸리는 시간을 회전 지연 시간이라고 함
    3. 헤드는 원하는 섹터에 있는 데이터를 읽어 전송하는데, 이때 걸리는 시간을 전송 시간이라고 함

| 디스크의 데이터 전송 시간 : 데이터 전송 시간 = 탐색 시간 + 회전 지연 시간 + 전송 시간 |
| ------------------------------------------------------------ |

#### 디스크 장치 관리

- **파티션**
  - 파티션은 디스크를 논리적으로 분할하는 작업이고 포매팅은 디스크를 초기화하는 작업임
  - 디스크를 논리적으로 분할하는 작업으로, 보통은 파티션 하나에 하나의 파일 시스템이 탑재됨
- **포매팅**
  - 디스크에 파일 시스템을 탑재하고 디스크 표면을 초기화하여 사용할 수 있는 형태로 만드는 작업
  - 빈 저장장치에 파일 테이블을 탑재하는 것
  - 하드디스크를 처음 사용할 때는 느린 포매팅을 하고, 하드디스크를 사용하다가 다시 포매팅을 해야 할 때는 빠른 포매팅을 하면 됨
- **조각 모음**
  - 하드디스크에 조각이 많이 생기면 큰 파일이 여러 조각으로 나뉘어 저장되고 이를 읽기 위해 하드디스크의 여러 곳을 돌아다녀야 하기 때문에 성능 저하로 이어짐
  - 하드디스크는 주기적으로 조각 모음을 해주어야 함

#### 네트워크 저장장치

- **DAS**
  - 서버와 같은 컴퓨터에 직접 연결된 저장장치, HAS라고도 불림
  - 예 : 윈도우의 파일 공유로, 여러 컴퓨터 중 하나를 파일 공유 서버로 지정하고 나머지 컴퓨터에서 서버로 지정된 컴퓨터에 접근하여 파일을 이용하는 방식
  - 컴퓨터에 직접 연결된 저장장치를 사용하기 때문에 다른 운영체제가 쓰는 파일 시스템을 사용할 수 없음
  - 데이터의 관리나 백업을 사용자가 직접 해야 하는 번거로움도 있음
- **NAS**
  - 기존의 저장장치를 LAN이나 WAN에 붙여서 사용하는 방식
- **SAN**
  - 데이터 서버, 백업 서버, RAID 등의 장치를 네트워크로 묶고 데이터 접근을 위한 서버를 두는 형태

### 디스크 스케줄링

+ 디스크 스케줄링 : 트랙의 이동을 최소화하여 탐색 시간을 줄이는 것이 목적
+ **FCFS 디스크 스케줄링**
  + 가장 단순한 디스크 스케줄링 방식으로, 요청이 들어온 트랙 순서대로 서비스함
+ **SSTF 디스크 스케줄링**
  + 현재 헤드가 있는 위치에서 가장 가까운 트랙부터 서비스함
  + 만약 다음에 서비스할 두 트랙의 거리가 같다면 먼저 요청받은 트랙을 서비스함
  + 효율성은 좋지만 아사 현상을 일으킬 수 있음(헤드가 중간에 위치하면 가장 안쪽이나 가장 바깥쪽에 있는 트랙을 서비스 받을 확률이 낮아지기 때문이다.)
+ **블록 SSTF 디스크 스케줄링**
  + 큐에 있는 트랙 요청을 일정한 블록 형태로 묶음
  + 모든 트랙이 불록 안에서만 움직임
  + 에이징을 사용하여 공평성을 보장하지만 성능은 FCFS 디스크 스케줄링만큼 좋지 않음
+ **SCAN 디스크 스케줄링**
  + 헤드가 움직이기 시작하면 맨 마지막 트랙에 도착할 때 까지 뒤돌아가지 않고 계속 앞으로만 전진하면서 요청받은 트랙을 서비스함
  + 동일한 트랙이나 실린더 요청이 연속적으로 발생하면 헤드가 더 이상 나아가지 못하고 제자리에 머물게 되어 바깥쪽 트랙이 아사 현상을 겪는 문제가 발생
+ **C-SCAN**
  + SCAN 디스크 스케줄링을 변형한 것
  + 헤드가 한쪽 방향으로 움직일 때는 요청받은 트랙을 서비스하고 반대 방향으로 돌아올 때는 서비스하지 않고 이동만 함
  + 작업 없이 헤드를 이동하는 것은 매우 비효율적
  + 동일한 트랙(실린터) 요청이 연속적으로 발생하면 SCAN 디스크 스케줄링과 마찬가지로 바깥쪽 트랙이 아사 현상을 겪음
+ **LOOK 디스크 스케줄링**
  + 더 이상 서비스할 트랙이 없으면 헤드가 끝까지 가지 않고 중간에서 방향을 바꿈
+ **C-LOOK 디스크 스케줄링**
  + 디스크 스케줄링의 LOOK 버전
  + 한쪽 방향으로만 서비스하는 C-SCAN 디스크 스케줄링과 유사
  + 차이점은 더 이상 서비스할 트랙이 없으면 헤드가 중간에서 방향을 바꿀 수 있음
+ **SLTF 디스크 스케줄링**
  + 최소 지연 우선 기법
  + 큐에 들어온 요처을 디스크의 회전 방향에 맞춰 1번, 5번, 9번으로 재정렬한 후 서비스

### RAID

- **RAID**
  - 자동으로 백업을 하고 장애가 발생하면 이를 복구하는 시스템으로 레이드라고 읽음
  - 하나의 원본 디스크와 같은 크기의 백업 디스크에 같은 내용을 동시에 저장하고, 하나의 디스크가 고장 났을 때 다른 디스크를 사용하여 데이터를 복구하는 것
  - RAID 0,1,10 외에 RAID 2,3,4,5,6,50,60 등도 있음
- **RAID 0(스트라이핑)**
  - 하나의 데이터를 2개의 디스크에 나누어 저장하여 장애 시 백업 디스크로 활용
  - 데이터가 똑같이 여러 디스크에 복사되기 때문에 미러링이라고 부름
  - 같은 크기의 디스크를 최소 2개 이상 필요로 하며 짝수 개의 디스크로 구성
  - 단점 : 저장하는 데이터와 같은 크기의 디스크가 하나 더 필요하기 때문에 비용이 증가한다는 것
  - 단점 : 같은 내용을 두 번 저장하기 때문에 속도가 느려질 수 있음
- **RAID 2**
  - 오류를 검출하는 기능이 없는 디스크에 대해 오류 교정 코드를 따로 관리하고, 오류가 발생하면 이 코드를 이용하여 디스크를 복구함
  - **오류 검출 코드** : 오류가 발생했는지 확인할 수 있는 코드로, 패리티 비트가 대표적인 예
  - **오류 교정 코드** : 오류가 발생했는지 확인하는 동시에 오류를 교정할 수 있는 코드로, 허밍 코드가 대표적인 예
  - RAID 2에서는 데이터가 비트 단위로 저장
  - n개의 디스크에 대해 오류 교정 코드를 저장하기 위한 n-1개의 추가 디스크를 필요로 하므로 RAID 1보다는 작은 저장 공간을 요구하지만 오류 교정 코드를 계산하는 데 많은 시간을 소비함
- **RAID 3**
  - 섹터 단위로 데이터를 나누어 저장
  - N-way 패리티 비트를 구성한 후 데이터 디스크가 아닌 별도의 디스크에 보관함으로써 장애 발생 시 오류를 복구함
  - RAID 3에서 추가되는 디스크의 양은 4개의 디스크당 1개 정도
  - 추가되는 디스크의 양은 적지만 N-way 패리티 비트를 구성하는 데 필요한 계산량이 많다는 것이 단점
- **RAID 4**
  - 데이터를 하나의 디스크에 블록 단위로 저장하고 패리티 비트를 블록과 연결하여 구성
  - 데이터가 저장되는 디스크와 패리티 비트가 저장되는 디스크만 동작한다는 것이 장점
  - RAID 3과 마찬가지로 패리티 비트를 추가하기 위한 계산량이 많음 그러나 추가되는 디스크의 양은 적음
- **RAID 5**
  - 패리티 비트를 여러 디스크에 분산하여 보관함으로써 패리티 비트 디스크의 병목 현상을 완화함
  - 패리티 비트를 해당 데이터가 없는 디스크에 보관
  - 한 디스크에 장애가 발생하면 다른 디스크에 있는 패리티 비트를 이용하여 데이터를 복구할 수 있음
- **RAID 6**
  - RAID 5와 같은 방식이지만 패리티 비트가 2개
  - 패리티 비트를 2개씩 운영하기 때문에 RAID 5보다 계산량이 많다는 것과 4개의 디스크당 2개의 추가 디스크가 필요하다는 것
- **RAID 10**
  - 빠른 입출력이 장점인 RAID 0과 복구 기능을 가진 RAID 1을 결합한 RAID 10이 등장
- **RAID 50과 RAID 60**
  - RAID 50에서는 RAID 5로 묶은 두 쌍을 다시 RAID 0으로 묶어 사용
  - RAID 60에서는 RAID 6으로 묶은 두 쌍을 다시 RAID 0으로 묶어 사용